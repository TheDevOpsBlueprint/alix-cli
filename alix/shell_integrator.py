import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional

from alix.shell_detector import ShellDetector, ShellType
from alix.storage import AliasStorage
from alix.models import Alias, TEST_ALIAS_NAME

class ShellIntegrator:
    """Apply aliases to shell configuration files"""

    ALIX_MARKER_START = "# === ALIX MANAGED ALIASES START ==="
    ALIX_MARKER_END = "# === ALIX MANAGED ALIASES END ==="
    ALIX_COMPLETION_MARKER_START = "# === ALIX MANAGED COMPLETIONS START ==="
    ALIX_COMPLETION_MARKER_END = "# === ALIX MANAGED COMPLETIONS END ==="

    def __init__(self):
        self.detector = ShellDetector()
        self.storage = AliasStorage()
        self.shell_type = self.detector.detect_current_shell()

    def get_target_file(self) -> Optional[Path]:
        """Get the appropriate shell config file to modify"""
        configs = self.detector.find_config_files(self.shell_type)

        # Priority order for different shells
        priority_files = {
            ShellType.BASH: [".bash_aliases", ".bashrc", ".bash_profile"],
            ShellType.ZSH: [".zsh_aliases", ".zshrc"],
            ShellType.FISH: [".config/fish/config.fish"],
        }

        shell_priorities = priority_files.get(self.shell_type, [])

        for priority in shell_priorities:
            if priority in configs:
                return configs[priority]

        # Return first available if no priority match
        return next(iter(configs.values())) if configs else None

    def backup_shell_config(self, config_file: Path) -> Path:
        """Create backup of shell configuration file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = config_file.parent / f"{config_file.name}.alix_backup_{timestamp}"
        shutil.copy2(config_file, backup_path)
        return backup_path

    def export_aliases(self, shell_type: ShellType) -> str:
        """Export aliases in shell-specific format"""
        aliases = self.storage.list_all()

        if shell_type == ShellType.FISH:
            lines = [f"alias {a.name}='{a.command}'" for a in aliases]
        else:  # Bash, Zsh, Sh
            lines = [f"alias {a.name}='{a.command}'" for a in aliases]

        return "\n".join(lines)

    def preview_aliases(self, target_file: Optional[Path] = None) -> tuple[str, str]:
        """Get old and new config for dry-run"""        
        # Read current config
        if target_file == None:
            content = ""
        else:
            content = target_file.read_text()

        # Remove old alix section if exists
        start_idx = content.find(self.ALIX_MARKER_START)
        end_idx = content.find(self.ALIX_MARKER_END)

        old_alix = ""
        if start_idx != -1 and end_idx != -1:
            old_alix = content[start_idx:]
            content = content[:start_idx] + content[end_idx + len(self.ALIX_MARKER_END) + 1:]

        # Add new aliases section
        aliases_section = f"\n{self.ALIX_MARKER_START}\n"
        aliases_section += f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        aliases_section += self.export_aliases(self.shell_type)
        aliases_section += f"\n{self.ALIX_MARKER_END}\n"
        
        return (old_alix, aliases_section)
    
    def apply_aliases(self, target_file: Optional[Path] = None) -> tuple[bool, str]:
        """Apply aliases to shell configuration file"""
        if not target_file:
            target_file = self.get_target_file()

        if not target_file:
            return False, "No shell configuration file found"

        # Create backup
        backup_path = self.backup_shell_config(target_file)

        # Read current config
        content = target_file.read_text()

        # Remove old alix section if exists
        start_idx = content.find(self.ALIX_MARKER_START)
        end_idx = content.find(self.ALIX_MARKER_END)

        if start_idx != -1 and end_idx != -1:
            content = (
                content[:start_idx] + content[end_idx + len(self.ALIX_MARKER_END) + 1 :]
            )

        # Add new aliases section
        aliases_section = f"\n{self.ALIX_MARKER_START}\n"
        aliases_section += (
            f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        )
        aliases_section += self.export_aliases(self.shell_type)
        aliases_section += f"\n{self.ALIX_MARKER_END}\n"

        # Append to file
        content = content.rstrip() + aliases_section
        target_file.write_text(content)

        return (
            True,
            f"Applied {len(self.storage.list_all())} aliases to {target_file.name}",
        )

    # NEW METHOD: apply_single_alias
    def apply_single_alias(
        self, alias: Alias, auto_reload: bool = True
    ) -> tuple[bool, str]:
        """Apply a single alias immediately to the current shell session"""
        target_file = self.get_target_file()

        if not target_file:
            return False, "No shell configuration file found"

        # Read current config
        content = target_file.read_text()

        # Check if alix section exists
        start_idx = content.find(self.ALIX_MARKER_START)
        end_idx = content.find(self.ALIX_MARKER_END)

        alias_line = f"alias {alias.name}='{alias.command}'"

        if start_idx != -1 and end_idx != -1:
            # Insert into existing alix section
            section_content = content[start_idx:end_idx]
            if f"alias {alias.name}=" not in section_content:
                # Add before the end marker
                new_content = content[:end_idx] + f"{alias_line}\n" + content[end_idx:]
                target_file.write_text(new_content)
        else:
            # Create new alix section
            aliases_section = f"\n{self.ALIX_MARKER_START}\n"
            aliases_section += f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            aliases_section += f"{alias_line}\n"
            aliases_section += f"{self.ALIX_MARKER_END}\n"

            content = content.rstrip() + aliases_section
            target_file.write_text(content)

        if auto_reload:
            self.reload_shell_config()

        return True, f"Applied alias '{alias.name}' to {target_file.name}"

    # NEW METHOD: reload_shell_config
    def reload_shell_config(self) -> bool:
        """Attempt to reload shell configuration"""
        import subprocess
        import os

        target_file = self.get_target_file()
        if not target_file:
            return False

        # Write a temporary script to source the config
        temp_script = f"""
#!/bin/bash
source {target_file}
alias {TEST_ALIAS_NAME} 2>/dev/null || true
"""

        try:
            # For the current Python process environment
            result = subprocess.run(
                ["bash", "-c", f"source {target_file}"], capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception:
            return False


    # NEW METHOD: install_completions
    def install_completions(self, script_content: str, shell_type: Optional[ShellType] = None) -> tuple[bool, str]:
        """Install shell completion script and source it from the user's shell config.

        For bash and zsh, writes a script under ~/.config/alix/completions and ensures
        it is sourced from the primary shell config file. For fish, installs to
        ~/.config/fish/completions/alix.fish which fish autoloads.
        """
        stype = shell_type or self.shell_type

        try:
            home = Path.home()
            if stype == ShellType.FISH:
                completions_dir = home / ".config" / "fish" / "completions"
                completions_dir.mkdir(parents=True, exist_ok=True)
                target_completion = completions_dir / "alix.fish"
                target_completion.write_text(script_content)
                return True, f"Installed fish completions to {target_completion}"

            # bash / zsh: store our script in ~/.config/alix/completions and source it
            alix_comp_dir = home / ".config" / "alix" / "completions"
            alix_comp_dir.mkdir(parents=True, exist_ok=True)

            suffix = "bash" if stype == ShellType.BASH else "zsh"
            target_completion = alix_comp_dir / f"alix.{suffix}"
            target_completion.write_text(script_content)

            # Ensure shell config exists and add a managed sourcing section
            config_file = self.get_target_file()
            if not config_file:
                return False, "No shell configuration file found to source completions from"

            current = config_file.read_text()
            # Remove prior managed section if present
            start_idx = current.find(self.ALIX_COMPLETION_MARKER_START)
            end_idx = current.find(self.ALIX_COMPLETION_MARKER_END)
            if start_idx != -1 and end_idx != -1:
                current = current[:start_idx] + current[end_idx + len(self.ALIX_COMPLETION_MARKER_END) + 1:]

            completion_block = "\n" + self.ALIX_COMPLETION_MARKER_START + "\n"
            completion_block += f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            completion_block += f"# Enable CLI tab completion for alix\n"
            completion_block += f"source {target_completion}\n"
            completion_block += self.ALIX_COMPLETION_MARKER_END + "\n"

            new_content = current.rstrip() + completion_block
            config_file.write_text(new_content)

            return True, f"Installed {suffix} completions to {target_completion} and sourced from {config_file}"
        except Exception as exc:
            return False, f"Failed to install completions: {exc}"

